# -*- coding: utf-8 -*-
"""MLlab01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ULEaNcB-K1R_TiIZ9YDg_RwXBGP3qrNj
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np

x = np.random.rand(10000,1)

fig, ax = plt.subplots(nrows=1, ncols=2,figsize=(10,4))
n1bins, n2bins = 4, 40

ax[0].hist(x, bins=n1bins)
ax[0].set_ylim(0,250)
ax[0].set_xlabel("Bins", fontsize=16)
ax[0].set_ylabel("Count", fontsize=16)
ax[0].set_title("Histogram: bins=%4d"%(n1bins), fontsize=16)

ax[1].hist(x, bins=n2bins)
ax[1].set_ylim(0,250)
ax[1].set_xlabel("Bins", fontsize=16)
ax[1].set_ylabel("Count", fontsize=16)
ax[1].set_title("Histogram: bins=%4d"%(n2bins), fontsize=16)

plt.savefig("histograms_uniform.png")
plt.tight_layout()

N = 1000
x1 = np.zeros(N)
for n in range(N):
  x1[n] = np.sum(np.random.rand(12,1))- np.sum(np.random.rand(12,1))
fig, ax = plt.subplots(figsize=(5,5))
ax.hist(x1, 20)

MaxTrial = 2000
sampleSizeRange = np.linspace(100,200,40)
plotVar = np.zeros(len(sampleSizeRange))

for sSize in range(len(sampleSizeRange)):
  numSamples = int(sampleSizeRange[sSize])
  vStrial = np.zeros(MaxTrial)

  for trial in range(MaxTrial):
    xx=np.random.randn(numSamples,1)
    vStrial[trial]=np.var(xx)

  plotVar[sSize]=np.var(vStrial)

fig,ax=plt.subplots(figsize=(4,4))
ax.set_xlabel("Sample Variance", fontsize=10)
ax.set_ylabel("Sample Size", fontsize=10)
ax.plot((plotVar))

def gauss2D(x,m,C):
 Ci=np.linalg.inv(C)
 dC=np.linalg.det(C1)
 num=np.exp(-0.5 *np.dot((x-m).T,np.dot(Ci,(x-m))))
 den=2*np.pi * dC
 return num/den

def twoDGaussianPlot(nx,ny,m,C):
  x=np.linspace(-5,5,nx)
  y=np.linspace(-5,5,ny)
  X,Y=np.meshgrid(x,y,indexing='ij')
  Z=np.zeros([nx, ny])
  for i in range(nx):
    for j in range(ny):
      xvec=np.array([X[i,j],Y[i,j]])
      Z[i,j]=gauss2D(xvec,m,C)
  return X,Y,Z

#Plotcontours
 #
 nx,ny=50,40
 m1=np.array([2.4,3.2])
 C1=np.array([[2,0], [0,2]],np.float32)
 Xp,Yp,Zp=twoDGaussianPlot(nx,ny,m1,C1)
 plt.contour(Xp,Yp, Zp,5)

C=np.array([[2.0,1.0],[1.0,2]])
 A=np.linalg.cholesky(C)
 print(A@A.T)

X=np.random.randn(1000,2)
 Y=X@A
 print(X.shape)
 print(Y.shape)

fig,ax=plt.subplots(figsize=(5,5))
ax.scatter(X[:,0],X[:,1],c="c",s=4)
ax.scatter(Y[:,0],Y[:,1],c="m",s=4)
ax.set_xlim(-6,6)
ax.set_ylim(-6,6)

theta = np.pi/3
u = [np.sin(theta), np.cos(theta)]
print("The vector: ", u)
print("Magnitude : ", np.sqrt(u[0]**2 + u[1]**2))
print("Angle: ", theta*180/np.pi)

yp = Y @ u
print(yp.shape)
print("Projected variance: ", np.var(yp))

# Store projected variances in pVars & plot
#
nPoints = 50
pVars = np.zeros(nPoints)
thRange = np.linspace(0, 2*np.pi, nPoints)
for n in range(nPoints):
  theta = thRange[n]
  u = [np.sin(theta), np.cos(theta)]
  pVars[n] = np.var(Y @ u)
fig, ax = plt.subplots(figsize=(5,3))
ax.plot(pVars)

ymin, ymax = ax.get_ylim()

print(f"Minimum value: {ymin}")
print(f"Maximum value: {ymax}")

covariance_matrix = np.cov(Y.T)
print(covariance_matrix)

# Compute the eigenvalues and eigenvectors
eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)

# Print the results
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:", eigenvectors)